"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cacheControlDirective = exports.resultWithMetadata = exports.useResponseCache = exports.defaultGetDocumentString = exports.defaultShouldCacheResult = exports.defaultBuildResponseCacheKey = void 0;
const tslib_1 = require("tslib");
const fast_json_stable_stringify_1 = tslib_1.__importDefault(require("fast-json-stable-stringify"));
const graphql_1 = require("graphql");
const core_1 = require("@envelop/core");
const utils_1 = require("@graphql-tools/utils");
const hash_sha256_js_1 = require("./hash-sha256.js");
const in_memory_cache_js_1 = require("./in-memory-cache.js");
/**
 * Default function used for building the response cache key.
 * It is exported here for advanced use-cases. E.g. if you want to short circuit and serve responses from the cache on a global level in order to completely by-pass the GraphQL flow.
 */
const defaultBuildResponseCacheKey = (params) => (0, hash_sha256_js_1.hashSHA256)([
    params.documentString,
    params.operationName ?? '',
    (0, fast_json_stable_stringify_1.default)(params.variableValues ?? {}),
    params.sessionId ?? '',
].join('|'));
exports.defaultBuildResponseCacheKey = defaultBuildResponseCacheKey;
/**
 * Default function used to check if the result should be cached.
 *
 * It is exported here for advanced use-cases. E.g. if you want to choose if
 * results with certain error types should be cached.
 *
 * By default, results with errors (unexpected, EnvelopError, or GraphQLError) are not cached.
 */
const defaultShouldCacheResult = (params) => {
    if (params.result.errors) {
        // eslint-disable-next-line no-console
        console.warn('[useResponseCache] Failed to cache due to errors');
        return false;
    }
    return true;
};
exports.defaultShouldCacheResult = defaultShouldCacheResult;
function defaultGetDocumentString(executionArgs) {
    return (0, core_1.getDocumentString)(executionArgs.document, graphql_1.print);
}
exports.defaultGetDocumentString = defaultGetDocumentString;
const originalDocumentMap = new WeakMap();
const addTypeNameToDocument = (0, utils_1.memoize1)(function addTypeNameToDocument(document) {
    let documentChanged = false;
    const newDocument = (0, graphql_1.visit)(document, {
        SelectionSet(node) {
            if (!node.selections.some(selection => selection.kind === graphql_1.Kind.FIELD && selection.name.value === '__typename')) {
                documentChanged = true;
                return {
                    ...node,
                    selections: [
                        {
                            kind: graphql_1.Kind.FIELD,
                            name: {
                                kind: graphql_1.Kind.NAME,
                                value: '__typename',
                            },
                        },
                        ...node.selections,
                    ],
                };
            }
            return node;
        },
    });
    if (documentChanged) {
        originalDocumentMap.set(newDocument, document);
    }
    return newDocument;
});
function useResponseCache({ cache = (0, in_memory_cache_js_1.createInMemoryCache)(), ttl: globalTtl = Infinity, session, enabled, ignoredTypes = [], ttlPerType = {}, ttlPerSchemaCoordinate = {}, scopePerSchemaCoordinate = {}, idFields = ['id'], invalidateViaMutation = true, buildResponseCacheKey = exports.defaultBuildResponseCacheKey, getDocumentString = defaultGetDocumentString, shouldCacheResult = exports.defaultShouldCacheResult, includeExtensionMetadata = typeof process !== 'undefined'
    ? // eslint-disable-next-line dot-notation
        process.env['NODE_ENV'] === 'development'
    : false, }) {
    const ignoredTypesMap = new Set(ignoredTypes);
    const processedSchemas = new WeakSet();
    // never cache Introspections
    ttlPerSchemaCoordinate = { 'Query.__schema': 0, ...ttlPerSchemaCoordinate };
    return {
        onParse() {
            return ({ result, replaceParseResult }) => {
                if (!originalDocumentMap.has(result) && result.kind === graphql_1.Kind.DOCUMENT) {
                    const newDocument = addTypeNameToDocument(result);
                    replaceParseResult(newDocument);
                }
            };
        },
        onSchemaChange({ schema }) {
            if (processedSchemas.has(schema)) {
                return;
            }
            // Check if the schema has @cacheControl directive
            const cacheControlDirective = schema.getDirective('cacheControl');
            if (cacheControlDirective) {
                (0, utils_1.mapSchema)(schema, {
                    [utils_1.MapperKind.COMPOSITE_TYPE]: type => {
                        const cacheControlAnnotations = (0, utils_1.getDirective)(schema, type, 'cacheControl');
                        cacheControlAnnotations?.forEach(cacheControl => {
                            const ttl = cacheControl.maxAge * 1000;
                            if (ttl != null) {
                                ttlPerType[type.name] = ttl;
                            }
                            if (cacheControl.scope) {
                                scopePerSchemaCoordinate[`${type.name}`] = cacheControl.scope;
                            }
                        });
                        return type;
                    },
                    [utils_1.MapperKind.FIELD]: (fieldConfig, fieldName, typeName) => {
                        const cacheControlAnnotations = (0, utils_1.getDirective)(schema, fieldConfig, 'cacheControl');
                        cacheControlAnnotations?.forEach(cacheControl => {
                            const ttl = cacheControl.maxAge * 1000;
                            if (ttl != null) {
                                ttlPerSchemaCoordinate[`${typeName}.${fieldName}`] = ttl;
                            }
                            if (cacheControl.scope) {
                                scopePerSchemaCoordinate[`${typeName}.${fieldName}`] = cacheControl.scope;
                            }
                        });
                        return fieldConfig;
                    },
                });
            }
            processedSchemas.add(schema);
        },
        async onExecute(onExecuteParams) {
            const identifier = new Map();
            const types = new Set();
            const sessionId = session(onExecuteParams.args.contextValue);
            let currentTtl;
            let skip = false;
            const processResult = (result) => (0, utils_1.visitResult)(result, {
                document: originalDocumentMap.get(onExecuteParams.args.document) ??
                    onExecuteParams.args.document,
                variables: onExecuteParams.args.variableValues,
                operationName: onExecuteParams.args.operationName ?? undefined,
                rootValue: onExecuteParams.args.rootValue,
                context: onExecuteParams.args.contextValue,
            }, onExecuteParams.args.schema, new Proxy({}, {
                get(_, typename) {
                    let typenameCalled = 0;
                    if (ignoredTypesMap.has(typename)) {
                        skip = true;
                        return;
                    }
                    if (scopePerSchemaCoordinate[typename] === 'PRIVATE' && !sessionId) {
                        skip = true;
                        return;
                    }
                    types.add(typename);
                    if (typename in ttlPerType) {
                        currentTtl = calculateTtl(ttlPerType[typename], currentTtl);
                    }
                    return new Proxy((val) => val, {
                        // Needed for leaf values such as scalars, enums etc
                        // They don't have fields so visitResult expects functions for those
                        apply(_, __, [val]) {
                            return val;
                        },
                        get(_, fieldName) {
                            if (fieldName === '__typename') {
                                typenameCalled++;
                            }
                            if (fieldName === '__leave' &&
                                /**
                                 * The visitResult function is called for each field in the selection set.
                                 * But visitResult function looks for __typename field visitor even if it is not there in the document
                                 * So it calls __typename field visitor twice if it is also in the selection set.
                                 * That's why we need to count the number of times it is called.
                                 *
                                 * Default call of __typename https://github.com/ardatan/graphql-tools/blob/master/packages/utils/src/visitResult.ts#L277
                                 * Call for the field node https://github.com/ardatan/graphql-tools/blob/master/packages/utils/src/visitResult.ts#L272
                                 */ typenameCalled < 2) {
                                return (root) => {
                                    delete root.__typename;
                                    return root;
                                };
                            }
                            if (scopePerSchemaCoordinate[`${typename}.${fieldName}`] === 'PRIVATE' &&
                                !sessionId) {
                                skip = true;
                                return;
                            }
                            if (idFields.includes(fieldName)) {
                                return (id) => {
                                    identifier.set(`${typename}:${id}`, { typename, id });
                                    return id;
                                };
                            }
                            return undefined;
                        },
                    });
                },
            }));
            if (invalidateViaMutation !== false) {
                const operationAST = (0, graphql_1.getOperationAST)(onExecuteParams.args.document, onExecuteParams.args.operationName);
                if (operationAST?.operation === 'mutation') {
                    return {
                        onExecuteDone({ result, setResult }) {
                            if ((0, core_1.isAsyncIterable)(result)) {
                                // eslint-disable-next-line no-console
                                console.warn('[useResponseCache] AsyncIterable returned from execute is currently unsupported.');
                                return;
                            }
                            const processedResult = processResult(result);
                            cache.invalidate(identifier.values());
                            if (includeExtensionMetadata) {
                                setResult(resultWithMetadata(processedResult, {
                                    invalidatedEntities: Array.from(identifier.values()),
                                }));
                            }
                        },
                    };
                }
            }
            const cacheKey = await buildResponseCacheKey({
                documentString: getDocumentString(onExecuteParams.args),
                variableValues: onExecuteParams.args.variableValues,
                operationName: onExecuteParams.args.operationName,
                sessionId,
                context: onExecuteParams.args.contextValue,
            });
            if ((enabled?.(onExecuteParams.args.contextValue) ?? true) === true) {
                const cachedResponse = (await cache.get(cacheKey));
                if (cachedResponse != null) {
                    if (includeExtensionMetadata) {
                        onExecuteParams.setResultAndStopExecution(resultWithMetadata(cachedResponse, { hit: true }));
                    }
                    else {
                        onExecuteParams.setResultAndStopExecution(cachedResponse);
                    }
                    return;
                }
            }
            if (ttlPerSchemaCoordinate) {
                const typeInfo = new graphql_1.TypeInfo(onExecuteParams.args.schema);
                (0, graphql_1.visit)(onExecuteParams.args.document, (0, graphql_1.visitWithTypeInfo)(typeInfo, {
                    Field(fieldNode) {
                        const parentType = typeInfo.getParentType();
                        if (parentType) {
                            const schemaCoordinate = `${parentType.name}.${fieldNode.name.value}`;
                            const maybeTtl = ttlPerSchemaCoordinate[schemaCoordinate];
                            if (maybeTtl !== undefined) {
                                currentTtl = calculateTtl(maybeTtl, currentTtl);
                            }
                        }
                    },
                }));
            }
            async function maybeCacheResult(result, setResult) {
                const processedResult = processResult(result);
                // we only use the global ttl if no currentTtl has been determined.
                const finalTtl = currentTtl ?? globalTtl;
                if (skip || !shouldCacheResult({ cacheKey, result: processedResult }) || finalTtl === 0) {
                    if (includeExtensionMetadata) {
                        setResult(resultWithMetadata(processedResult, { hit: false, didCache: false }));
                    }
                    return;
                }
                cache.set(cacheKey, processedResult, identifier.values(), finalTtl);
                if (includeExtensionMetadata) {
                    setResult(resultWithMetadata(processedResult, { hit: false, didCache: true, ttl: finalTtl }));
                }
            }
            return {
                onExecuteDone(payload) {
                    if (!(0, core_1.isAsyncIterable)(payload.result)) {
                        maybeCacheResult(payload.result, payload.setResult);
                        return;
                    }
                    // When the result is an AsyncIterable, it means the query is using @defer or @stream.
                    // This means we have to build the final result by merging the incremental results.
                    // The merged result is then used to know if we should cache it and to calculate the ttl.
                    let result = {};
                    return {
                        onNext(payload) {
                            const { data, errors, extensions } = payload.result;
                            if (data) {
                                // This is the first result with the initial data payload sent to the client. We use it as the base result
                                if (data) {
                                    result = { data };
                                }
                                if (errors) {
                                    result.errors = errors;
                                }
                                if (extensions) {
                                    result.extensions = extensions;
                                }
                            }
                            if ('hasNext' in payload.result) {
                                const { incremental, hasNext } = payload.result;
                                if (incremental) {
                                    for (const patch of incremental) {
                                        (0, utils_1.mergeIncrementalResult)({ executionResult: result, incrementalResult: patch });
                                    }
                                }
                                if (!hasNext) {
                                    // The query is complete, we can process the final result
                                    maybeCacheResult(result, payload.setResult);
                                }
                            }
                        },
                    };
                },
            };
        },
    };
}
exports.useResponseCache = useResponseCache;
function resultWithMetadata(result, metadata) {
    return {
        ...result,
        extensions: {
            ...result.extensions,
            responseCache: {
                ...result.extensions?.responseCache,
                ...metadata,
            },
        },
    };
}
exports.resultWithMetadata = resultWithMetadata;
function calculateTtl(typeTtl, currentTtl) {
    if (typeof currentTtl === 'number') {
        return Math.min(currentTtl, typeTtl);
    }
    return typeTtl;
}
exports.cacheControlDirective = `
  enum CacheControlScope {
    PUBLIC
    PRIVATE
  }

  directive @cacheControl(maxAge: Int, scope: CacheControlScope) on FIELD_DEFINITION | OBJECT
`;
